{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA8BqB,qBAAqB;;;;gCACvB,0BAA0B;;;;gCAEpB,yBAAyB;;;;AAElD,SAAS,iBAAiB,GAAG;;AAEzB,QAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;AAC3B,QAAI,QAAQ,GAAG,+BAAS,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC;;AAE/C,QAAI,QAAQ,YAAA;QACR,qBAAqB,YAAA;QACrB,+BAA+B,YAAA;QAC/B,gBAAgB,YAAA,CAAC;;AAErB,aAAS,UAAU,GAAG;;AAElB,6BAAqB,GAAG,CAAC,CAAC;AAC1B,uCAA+B,GAAG,KAAK,CAAC;AACxC,wBAAgB,GAAG,GAAG,CAAC;;AAEvB,gBAAQ,CAAC,EAAE,CAAC,8BAAO,0BAA0B,EAAE,yBAAyB,EAAE,IAAI,CAAC,CAAC;AAChF,gBAAQ,CAAC,EAAE,CAAC,8BAAO,8BAA8B,EAAE,kBAAkB,EAAE,IAAI,CAAC,CAAC;KAChF;;AAED,aAAS,mBAAmB,GAAG;AAC3B,eAAO,+BAA+B,CAAC;KAC1C;;AAED,aAAS,oBAAoB,CAAC,KAAK,EAAE;AACjC,uCAA+B,GAAG,KAAK,CAAC;KAC3C;;AAED,aAAS,mBAAmB,GAAG;AAC3B,eAAO,qBAAqB,CAAC;KAChC;;AAED,aAAS,mBAAmB,GAAG;AAC3B,eAAO,gBAAgB,CAAC;KAC3B;;AAED,aAAS,mBAAmB,CAAC,KAAK,EAAE;AAChC,wBAAgB,GAAG,KAAK,CAAC;KAC5B;;AAED,aAAS,wCAAwC,CAAC,gBAAgB,EAAE,GAAG,EAAE,SAAS,EAAE,YAAY,EAAE;AAC9F,YAAI,gBAAgB,GAAG,GAAG,CAAC;;AAE3B,YAAI,YAAY,EAAE;;;;AAId,gBAAI,SAAS,IAAK,GAAG,CAAC,oBAAoB,IAAI,MAAM,CAAC,iBAAiB,AAAC,EAAE;AACrE,gCAAgB,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,qBAAqB,CAAC,OAAO,EAAE,GAAI,CAAC,gBAAgB,GAAG,GAAG,CAAC,oBAAoB,CAAA,GAAI,IAAI,AAAC,CAAC,CAAC;aAC7H,MAAM;AACH,gCAAgB,GAAG,GAAG,CAAC,mBAAmB,CAAC;aAC9C;SACJ,MAAM;AACH,gBAAI,SAAS,EAAE;AACX,gCAAgB,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,qBAAqB,CAAC,OAAO,EAAE,GAAG,CAAC,gBAAgB,GAAG,qBAAqB,CAAA,GAAI,IAAI,CAAC,CAAC;aACxH,MAAM;;AAEH,gCAAgB,GAAG,GAAG,CAAC,qBAAqB,CAAC;aAChD;SACJ;;AAED,eAAO,gBAAgB,CAAC;KAC3B;;AAED,aAAS,6CAA6C,CAAC,gBAAgB,EAAE,GAAG,EAAE,SAAS,EAAE;AACrF,eAAO,wCAAwC,CAAC,IAAI,CAAC,IAAI,EAAE,gBAAgB,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;KAChG;;AAED,aAAS,2CAA2C,CAAC,gBAAgB,EAAE,GAAG,EAAE,SAAS,EAAE;AACnF,eAAO,wCAAwC,CAAC,IAAI,CAAC,IAAI,EAAE,gBAAgB,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;KACtG;;AAED,aAAS,gCAAgC,CAAC,QAAQ,EAAE,MAAM,EAAE;AACxD,eAAQ,CAAC,QAAQ,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,OAAO,EAAE,GAAG,qBAAqB,GAAG,IAAI,CAAA,GAAI,IAAI,CAAE;KACpH;;AAED,aAAS,iCAAiC,CAAC,SAAS,EAAE,cAAc,EAAE;AAClE,YAAI,WAAW,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;AACzD,YAAI,kBAAkB,GAAG,cAAc,CAAC,sBAAsB,CAAC;;AAE/D,eAAO,SAAS,IAAI,WAAW,GAAG,kBAAkB,CAAA,AAAC,CAAC;KACzD;;AAED,aAAS,iCAAiC,CAAC,gBAAgB,EAAE,cAAc,EAAE;AACzE,YAAI,WAAW,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;AACzD,YAAI,kBAAkB,GAAG,cAAc,CAAC,sBAAsB,CAAC;;AAE/D,eAAO,gBAAgB,GAAG,WAAW,GAAG,kBAAkB,CAAC;KAC9D;;AAED,aAAS,sBAAsB,CAAC,OAAO,EAAE,SAAS,EAAE;AAChD,YAAI,0BAA0B,EAC1B,gBAAgB,EAChB,QAAQ,CAAC;;AAEb,YAAI,SAAS,EAAE;AACX,sCAA0B,GAAG,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,0BAA0B,CAAC;AACrG,4BAAgB,GAAG,OAAO,CAAC,qBAAqB,GAAG,0BAA0B,CAAC;AAC9E,oBAAQ,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,OAAO,EAAE,GAAI,gBAAgB,GAAG,IAAI,AAAC,CAAC,CAAC;SAC5F;;AAED,eAAO,QAAQ,CAAC;KACnB;;AAED,aAAS,4BAA4B,CAAC,cAAc,EAAE,SAAS,EAAE;AAC7D,YAAI,KAAK,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;AACnD,YAAI,GAAG,GAAG,KAAK,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC;AAC5D,YAAI,KAAK,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;AACvC,YAAI,CAAC,GAAG,cAAc,CAAC,eAAe,KAAK,AAAC,cAAc,CAAC,QAAQ,IAAI,cAAc,CAAC,QAAQ,CAAC,MAAM,GAAI,cAAc,CAAC,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAA,AAAC,CAAC;;AAEnL,YAAI,SAAS,EACT,GAAG,CAAC;;AAER,YAAI,CAAC,SAAS,EAAE,OAAO,KAAK,CAAC;;AAE7B,YAAI,CAAC,+BAA+B,IAAI,cAAc,CAAC,wBAAwB,EAAE;AAC7E,mBAAO,cAAc,CAAC,wBAAwB,CAAC;SAClD;;AAED,iBAAS,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;AAC3D,WAAG,GAAG,gCAAgC,CAAC,IAAI,IAAI,EAAE,EAAE,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;;;;AAIrF,aAAK,GAAG,IAAI,CAAC,GAAG,CAAE,GAAG,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,oBAAoB,EAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC5H,YAAI,UAAU,GAAI,KAAK,CAAC,SAAS,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,AAAC,CAAC;AACrE,YAAI,SAAS,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC;AACnG,WAAG,GAAG,CAAC,UAAU,IAAI,SAAS,IAAK,AAAC,UAAU,GAAG,CAAC,GAAI,SAAS,GAAG,SAAS,GAAG,UAAU,CAAA,GAAI,CAAC,CAAC;;AAE9F,aAAK,GAAG,EAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAC,CAAC;;AAEjC,eAAO,KAAK,CAAC;KAChB;;AAED,aAAS,yCAAyC,CAAC,cAAc,EAAE,eAAe,EAAE;AAChF,YAAI,eAAe,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;AAC7D,eAAO,eAAe,GAAG,eAAe,CAAC;KAC5C;;AAED,aAAS,yCAAyC,CAAC,cAAc,EAAE,kBAAkB,EAAE;AACnF,YAAI,eAAe,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;;AAE7D,eAAO,kBAAkB,GAAG,eAAe,CAAC;KAC/C;;AAED,aAAS,yBAAyB,CAAC,CAAC,EAAE;AAClC,YAAI,+BAA+B,IAAI,CAAC,CAAC,KAAK,EAAE,OAAO;;;;AAIvD,6BAAqB,IAAI,CAAC,CAAC,QAAQ,IAAI,gBAAgB,GAAG,CAAC,CAAC,UAAU,CAAA,AAAC,CAAC;AACxE,uCAA+B,GAAG,IAAI,CAAC;KAC1C;;AAED,aAAS,kBAAkB,CAAC,CAAC,EAAE;AAC3B,YAAI,+BAA+B,IAAI,CAAC,CAAC,KAAK,EAAE;AAC5C,mBAAO;SACV;;AAED,6BAAqB,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;;AAExC,uCAA+B,GAAG,IAAI,CAAC;KAC1C;;AAED,aAAS,iBAAiB,CAAC,cAAc,EAAE;;AAEvC,YAAI,kBAAkB,GAAG,cAAc,CAAC,sBAAsB,CAAC;AAC/D,YAAI,WAAW,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC;AACzD,eAAQ,WAAW,GAAG,kBAAkB,CAAE;KAC7C;;AAED,aAAS,KAAK,GAAG;AACb,gBAAQ,CAAC,GAAG,CAAC,8BAAO,0BAA0B,EAAE,yBAAyB,EAAE,IAAI,CAAC,CAAC;AACjF,gBAAQ,CAAC,GAAG,CAAC,8BAAO,8BAA8B,EAAE,kBAAkB,EAAE,IAAI,CAAC,CAAC;AAC9E,6BAAqB,GAAG,CAAC,CAAC;AAC1B,uCAA+B,GAAG,KAAK,CAAC;AACxC,wBAAgB,GAAG,GAAG,CAAC;KAC1B;;AAED,YAAQ,GAAG;AACP,kBAAU,EAAE,UAAU;AACtB,2BAAmB,EAAE,mBAAmB;AACxC,4BAAoB,EAAE,oBAAoB;AAC1C,2BAAmB,EAAE,mBAAmB;AACxC,2BAAmB,EAAE,mBAAmB;AACxC,2BAAmB,EAAE,mBAAmB;AACxC,qDAA6C,EAAE,6CAA6C;AAC5F,mDAA2C,EAAE,2CAA2C;AACxF,wCAAgC,EAAE,gCAAgC;AAClE,yCAAiC,EAAE,iCAAiC;AACpE,iDAAyC,EAAE,yCAAyC;AACpF,iDAAyC,EAAE,yCAAyC;AACpF,yCAAiC,EAAE,iCAAiC;AACpE,oCAA4B,EAAE,4BAA4B;AAC1D,8BAAsB,EAAE,sBAAsB;AAC9C,yBAAiB,EAAE,iBAAiB;AACpC,aAAK,EAAE,KAAK;KACf,CAAC;;AAEF,WAAO,QAAQ,CAAC;CACnB;;AAED,iBAAiB,CAAC,qBAAqB,GAAG,mBAAmB,CAAC;qBAC/C,8BAAa,mBAAmB,CAAC,iBAAiB,CAAC","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\n\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n\n        eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        var availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        var periodStart = representation.adaptation.period.start;\n        var presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        var periodStart = representation.adaptation.period.start;\n        var presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        var suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(representation, isDynamic) {\n        var start = representation.adaptation.period.start;\n        var end = start + representation.adaptation.period.duration;\n        var range = { start: start, end: end };\n        var d = representation.segmentDuration || ((representation.segments && representation.segments.length) ? representation.segments[representation.segments.length - 1].duration : 0);\n\n        var checkTime,\n            now;\n\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && representation.segmentAvailabilityRange) {\n            return representation.segmentAvailabilityRange;\n        }\n\n        checkTime = representation.adaptation.period.mpd.checkTime;\n        now = calcPresentationTimeFromWallTime(new Date(), representation.adaptation.period);\n        //the Media Segment list is further restricted by the CheckTime together with the MPD attribute\n        // MPD@timeShiftBufferDepth such that only Media Segments for which the sum of the start time of the\n        // Media Segment and the Period start time falls in the interval [NOW- MPD@timeShiftBufferDepth - @duration, min(CheckTime, NOW)] are included.\n        start = Math.max((now - representation.adaptation.period.mpd.timeShiftBufferDepth), representation.adaptation.period.start);\n        var timeAnchor = (isNaN(checkTime) ? now : Math.min(checkTime, now));\n        var periodEnd = representation.adaptation.period.start + representation.adaptation.period.duration;\n        end = (timeAnchor >= periodEnd  && (timeAnchor - d) < periodEnd ? periodEnd : timeAnchor) - d;\n        //end = (isNaN(checkTime) ? now : Math.min(checkTime, now)) - d;\n        range = {start: start, end: end};\n\n        return range;\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        var periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    function calcMpdRelativeTimeFromPeriodRelativeTime(representation, periodRelativeTime) {\n        var periodStartTime = representation.adaptation.period.start;\n\n        return periodRelativeTime + periodStartTime;\n    }\n\n    function onLiveEdgeSearchCompleted(e) {\n        if (isClientServerTimeSyncCompleted || e.error) return;\n\n        // the difference between expected and actual live edge time is supposed to be a difference between client\n        // and server time as well\n        clientServerTimeShift += e.liveEdge - (expectedLiveEdge + e.searchTime);\n        isClientServerTimeSyncCompleted = true;\n    }\n\n    function onTimeSyncComplete(e) {\n        if (isClientServerTimeSyncCompleted || e.error) {\n            return;\n        }\n\n        clientServerTimeShift = e.offset / 1000;\n\n        isClientServerTimeSyncCompleted = true;\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        var presentationOffset = representation.presentationTimeOffset;\n        var periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function reset() {\n        eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMpdRelativeTimeFromPeriodRelativeTime: calcMpdRelativeTimeFromPeriodRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}